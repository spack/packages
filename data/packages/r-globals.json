{
    "name": "r-globals",
    "aliases": [],
    "versions": [
        {
            "name": "0.14.0",
            "sha256": "203dbccb829ca9cc6aedb6f5e79cb126ea31f8dd379dff9111ec66e3628c32f3"
        },
        {
            "name": "0.12.4",
            "sha256": "7985356ad75afa1f795f8267a20dee847020c0207252dc075c614cef55d8fe6b"
        }
    ],
    "build_system": "RPackage",
    "conflicts": [],
    "variants": [],
    "homepage": "https://github.com/HenrikBengtsson/globals",
    "maintainers": [
        "glennpj"
    ],
    "patches": [],
    "resources": [],
    "description": "Identify Global Objects in R Expressions Identifies global (\"unknown\" or\n\"free\") objects in R expressions by code inspection using various\nstrategies, e.g. conservative or liberal. The objective of this package\nis to make it as simple as possible to identify global objects for the\npurpose of exporting them in distributed compute environments.\n",
    "dependencies": [
        {
            "name": "r",
            "description": "R is 'GNU S', a freely available language and environment for\nstatistical computing and graphics which provides a wide variety of\nstatistical and graphical techniques: linear and nonlinear modelling,\nstatistical tests, time series analysis, classification, clustering,\netc. Please consult the R project homepage for further information."
        },
        {
            "name": "r-codetools",
            "description": "Code analysis tools for R."
        }
    ],
    "dependent_to": [
        {
            "name": "r-future",
            "description": "Unified Parallel and Distributed Processing in R for Everyone The\npurpose of this package is to provide a lightweight and unified Future\nAPI for sequential and parallel processing of R expression via futures.\nThe simplest way to evaluate an expression in parallel is to use 'x %<-%\n{ expression }' with 'plan(multiprocess)'. This package implements\nsequential, multicore, multisession, and cluster futures. With these, R\nexpressions can be evaluated on the local machine, in parallel a set of\nlocal machines, or distributed on a mix of local and remote machines.\nExtensions to this package implement additional backends for processing\nfutures via compute cluster schedulers etc. Because of its unified API,\nthere is no need to modify any code in order switch from sequential on\nthe local machine to, say, distributed processing on a remote compute\ncluster. Another strength of this package is that global variables and\nfunctions are automatically identified and exported as needed, making it\nstraightforward to tweak existing code to make use of futures."
        },
        {
            "name": "r-future-apply",
            "description": "Apply Function to Elements in Parallel using Futures Implementations of\napply(), by(), eapply(), lapply(), Map(), mapply(), replicate(),\nsapply(), tapply(), and vapply() that can be resolved using any future-\nsupported backend, e.g. parallel on the local machine or distributed on\na compute cluster. These future_*apply() functions come with the same\npros and cons as the corresponding base-R *apply() functions but with\nthe additional feature of being able to be processed via the future\nframework."
        }
    ]
}