{
    "name": "perl-bioperl",
    "aliases": [],
    "versions": [
        {
            "name": "1.7.6",
            "sha256": "df2a3efc991b9b5d7cc9d038a1452c6dac910c9ad2a0e47e408dd692c111688d",
            "preferred": true
        },
        {
            "name": "1.007002",
            "sha256": "17aa3aaab2f381bbcaffdc370002eaf28f2c341b538068d6586b2276a76464a1",
            "url": "https://cpan.metacpan.org/authors/id/C/CJ/CJFIELDS/BioPerl-1.007002.tar.gz"
        }
    ],
    "build_system": "PerlPackage",
    "conflicts": [],
    "variants": [],
    "homepage": "https://metacpan.org/pod/BioPerl",
    "maintainers": [],
    "patches": [],
    "resources": [],
    "description": "BioPerl is the product of a community effort to produce Perl code which\nis useful in biology. Examples include Sequence objects, Alignment\nobjects and database searching objects. These objects not only do what\nthey are advertised to do in the documentation, but they also interact -\nAlignment objects are made from the Sequence objects, Sequence objects\nhave access to Annotation and SeqFeature objects and databases, Blast\nobjects can be converted to Alignment objects, and so on. This means\nthat the objects provide a coordinated and extensible framework to do\ncomputational biology. BioPerl development focuses on Perl classes, or\ncode that is used to create objects representing biological entities.\nThere are scripts provided in the scripts/ and examples/ directories but\nscripts are not the main focus of the BioPerl developers. Of course, as\nthe objects do most of the hard work for you, all you have to do is\ncombine a number of objects together sensibly to make useful scripts.\nThe intent of the BioPerl development effort is to make reusable tools\nthat aid people in creating their own sites or job-specific\napplications. The BioPerl website at http://bioperl.org also attempts to\nmaintain links and archives of standalone bio-related Perl tools that\nare not affiliated or related to the core BioPerl effort. Check the site\nfor useful code ideas and contribute your own if possible.\n",
    "dependencies": [
        {
            "name": "perl",
            "description": "Perl 5 is a highly capable, feature-rich programming language with over\n27 years of development."
        },
        {
            "name": "perl-module-build",
            "description": "Module::Build is a system for building, testing, and installing Perl\nmodules. It is meant to be an alternative to ExtUtils::MakeMaker.\nDevelopers may alter the behavior of the module through subclassing in a\nmuch more straightforward way than with MakeMaker. It also does not\nrequire a make on your system - most of the Module::Build code is pure-\nperl and written in a very cross-platform way."
        },
        {
            "name": "perl-uri",
            "description": "Uniform Resource Identifiers (absolute and relative)"
        },
        {
            "name": "perl-io-string",
            "description": "Emulate file interface for in-core strings"
        },
        {
            "name": "perl-data-stag",
            "description": "Structured Tags datastructures"
        },
        {
            "name": "perl-test-most",
            "description": "Most commonly needed test functions and features."
        },
        {
            "name": "perl-error",
            "description": "The Error package provides two interfaces. Firstly Error provides a\nprocedural interface to exception handling. Secondly Error is a base\nclass for errors/exceptions that can either be thrown, for subsequent\ncatch, or can simply be recorded."
        },
        {
            "name": "perl-graph",
            "description": "Graph data structures and algorithms"
        },
        {
            "name": "perl-http-message",
            "description": "HTTP style message (base class)"
        },
        {
            "name": "perl-io-stringy",
            "description": "This toolkit primarily provides modules for performing both traditional\nand object-oriented i/o) on things other than normal filehandles; in\nparticular, IO::Scalar, IO::ScalarArray, and IO::Lines. In the more-\ntraditional IO::Handle front, we have IO::AtomicFile which may be used\nto painlessly create files which are updated atomically. And in the\n\"this-may-prove-useful\" corner, we have IO::Wrap, whose exported\nwraphandle() function will clothe anything that's not a blessed object\nin an IO::Handle-like wrapper... so you can just use OO syntax and stop\nworrying about whether your function's caller handed you a string, a\nglobref, or a FileHandle."
        },
        {
            "name": "perl-ipc-run",
            "description": "IPC::Run allows you to run and interact with child processes using\nfiles, pipes, and pseudo-ttys. Both system()-style and scripted usages\nare supported and may be mixed. Likewise, functional and OO API styles\nare both supported and may be mixed."
        },
        {
            "name": "perl-list-moreutils",
            "description": "Provide the stuff missing in List::Util"
        },
        {
            "name": "perl-set-scalar",
            "description": "Set::Scalar - basic set operations"
        },
        {
            "name": "perl-test-requiresinternet",
            "description": "Easily test network connectivity"
        },
        {
            "name": "perl-xml-dom",
            "description": "This module extends the XML::Parser module by Clark Cooper. The\nXML::Parser module is built on top of XML::Parser::Expat, which is a\nlower level interface to James Clark's expat library."
        },
        {
            "name": "perl-xml-dom-xpath",
            "description": "XML::DOM::XPath allows you to use XML::XPath methods to query a DOM.\nThis is often much easier than relying only on getElementsByTagName."
        },
        {
            "name": "perl-xml-libxml",
            "description": "This module is an interface to libxml2, providing XML and HTML parsers\nwith DOM, SAX and XMLReader interfaces, a large subset of DOM Layer 3\ninterface and a XML::XPath-like interface to XPath API of libxml2. The\nmodule is split into several packages which are not described in this\nsection; unless stated otherwise, you only need to use XML::LibXML; in\nyour programs."
        },
        {
            "name": "perl-xml-sax",
            "description": "XML::SAX is a SAX parser access API for Perl. It includes classes and\nAPIs required for implementing SAX drivers, along with a factory class\nfor returning any SAX parser installed on the user's system."
        },
        {
            "name": "perl-xml-sax-base",
            "description": "This module has a very simple task - to be a base class for PerlSAX\ndrivers and filters. It's default behaviour is to pass the input\ndirectly to the output unchanged. It can be useful to use this module as\na base class so you don't have to, for example, implement the\ncharacters() callback."
        },
        {
            "name": "perl-xml-sax-writer",
            "description": "A new XML Writer was needed to match the SAX2 effort because quite\nnaturally no existing writer understood SAX2. My first intention had\nbeen to start patching XML::Handler::YAWriter as it had previously been\nmy favourite writer in the SAX1 world."
        },
        {
            "name": "perl-xml-twig",
            "description": "This module provides a way to process XML documents. It is build on top\nof XML::Parser. The module offers a tree interface to the document,\nwhile allowing you to output the parts of it that have been completely\nprocessed. It allows minimal resource (CPU and memory) usage by building\nthe tree only for the parts of the documents that need actual\nprocessing, through the use of the twig_roots and\ntwig_print_outside_roots options. The finish and finish_print methods\nalso help to increase performances. XML::Twig tries to make simple\nthings easy so it tries its best to takes care of a lot of the (usually)\nannoying (but sometimes necessary) features that come with XML and\nXML::Parser."
        },
        {
            "name": "perl-xml-writer",
            "description": "XML::Writer is a helper module for Perl programs that write an XML\ndocument. The module handles all escaping for attribute values and\ncharacter data and constructs different types of markup, such as tags,\ncomments, and processing instructions. By default, the module performs\nseveral well-formedness checks to catch errors during output. This\nbehaviour can be extremely useful during development and debugging, but\nit can be turned off for production-grade code. The module can operate\neither in regular mode in or Namespace processing mode. In Namespace\nmode, the module will generate Namespace Declarations itself, and will\nperform additional checks on the output."
        },
        {
            "name": "perl-yaml",
            "description": "This module has been released to CPAN as YAML::Old, and soon YAML.pm\nwill be changed to just be a frontend interface module for all the\nvarious Perl YAML implementation modules, including YAML::Old"
        },
        {
            "name": "perl-libwww-perl",
            "description": "The libwww-perl collection is a set of Perl modules which provides a\nsimple and consistent application programming interface to the World-\nWide Web. The main focus of the library is to provide classes and\nfunctions that allow you to write WWW clients."
        },
        {
            "name": "perl-libxml-perl",
            "description": "libxml-perl is a collection of smaller Perl modules, scripts, and\ndocuments for working with XML in Perl. libxml-perl software works in\ncombination with XML::Parser, PerlSAX, XML::DOM, XML::Grove and others."
        }
    ],
    "dependent_to": [
        {
            "name": "prokka",
            "description": "Prokka is a software tool to annotate bacterial, archaeal and viral\ngenomes quickly and produce standards-compliant output files."
        },
        {
            "name": "autofact",
            "description": "An Automatic Functional Annotation and Classification Tool"
        },
        {
            "name": "velvetoptimiser",
            "description": "Automatically optimise three of Velvet's assembly parameters."
        },
        {
            "name": "guidance",
            "description": "Guidance: Accurate detection of unreliable alignment regions accounting\nfor the uncertainty of multiple parameters."
        },
        {
            "name": "perl-bio-searchio-hmmer",
            "description": "BioPerl parser to HMMER output."
        },
        {
            "name": "maker",
            "description": "MAKER is a portable and easily configurable genome annotation pipeline.\nIt's purpose is to allow smaller eukaryotic and prokaryotic\ngenomeprojects to independently annotate their genomes and to create\ngenome databases. MAKER identifies repeats, aligns ESTs and proteins to\na genome, produces ab-initio gene predictions and automatically\nsynthesizes these data into gene annotations having evidence-based\nquality values. MAKER is also easily trainable: outputs of preliminary\nruns can be used to automatically retrain its gene prediction algorithm,\nproducing higher quality gene-models on subsequent runs. MAKER's inputs\nare minimal and its ouputs can be directly loaded into a GMOD database.\nThey can also be viewed in the Apollo genome browser; this feature of\nMAKER provides an easy means to annotate, view and edit individual\ncontigs and BACs without the overhead of a database. MAKER should prove\nespecially useful for emerging model organism projects with minimal\nbioinformatics expertise and computer resources. Note: MAKER requires\nregistration. Fill out the form at\nhttp://yandell.topaz.genetics.utah.edu/cgi-bin/maker_license.cgi to get\na download link. Spack will search your current directory for the\ndownload file. Alternatively, add this file to a mirror so that Spack\ncan find it. For instructions on how to set up a mirror, see\nhttp://spack.readthedocs.io/en/latest/mirrors.html"
        }
    ]
}