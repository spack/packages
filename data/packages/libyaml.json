{
    "name": "libyaml",
    "aliases": [],
    "versions": [
        {
            "name": "master",
            "branch": "master"
        },
        {
            "name": "0.2.5",
            "sha256": "c642ae9b75fee120b2d96c712538bd2cf283228d2337df2cf2988e3c02678ef4"
        },
        {
            "name": "0.2.4",
            "sha256": "d80aeda8747b7c26fbbfd87ab687786e58394a8435ae3970e79cb97882e30557"
        },
        {
            "name": "0.2.3",
            "sha256": "08bbb80284d77092e68a6f69f1e480e8ed93e215c47b2ca29290e3bd5a191108"
        },
        {
            "name": "0.2.2",
            "sha256": "4a9100ab61047fd9bd395bcef3ce5403365cafd55c1e0d0299cde14958e47be9"
        },
        {
            "name": "0.2.1",
            "sha256": "78281145641a080fb32d6e7a87b9c0664d611dcb4d542e90baf731f51cbb59cd"
        },
        {
            "name": "0.1.7",
            "sha256": "8088e457264a98ba451a90b8661fcb4f9d6f478f7265d48322a196cec2480729"
        },
        {
            "name": "0.1.6",
            "sha256": "7da6971b4bd08a986dd2a61353bc422362bd0edcc67d7ebaac68c95f74182749"
        },
        {
            "name": "0.1.5",
            "sha256": "fa87ee8fb7b936ec04457bc044cd561155e1000a4d25029867752e543c2d3bef"
        },
        {
            "name": "0.1.4",
            "sha256": "7bf81554ae5ab2d9b6977da398ea789722e0db75b86bffdaeb4e66d961de6a37"
        },
        {
            "name": "0.1.3",
            "sha256": "a8bbad7e5250b3735126b7e3bd9f6fce9db19d6be7cc13abad17a24b59ec144a"
        },
        {
            "name": "0.1.2",
            "sha256": "5beb94529cc7ac79b17e354f9b03aea311f5af17be5d48bc39e6f1db5059f70f"
        },
        {
            "name": "0.1.1",
            "sha256": "76444692a94de4e6776a1bdf3b735e8f016bb374ae7c60496f8032fdc6085889"
        }
    ],
    "build_system": "AutotoolsPackage",
    "conflicts": [],
    "variants": [],
    "homepage": "https://pyyaml.org/wiki/LibYAML",
    "maintainers": [],
    "patches": [],
    "resources": [],
    "description": "A C library for parsing and emitting YAML.\n",
    "dependencies": [
        {
            "name": "automake",
            "description": "Automake -- make file builder part of autotools"
        },
        {
            "name": "autoconf",
            "description": "Autoconf -- system configuration part of autotools"
        },
        {
            "name": "libtool",
            "description": "libtool -- library building part of autotools."
        },
        {
            "name": "m4",
            "description": "GNU M4 is an implementation of the traditional Unix macro processor."
        }
    ],
    "dependent_to": [
        {
            "name": "py-pyyaml",
            "description": "PyYAML is a YAML parser and emitter for Python."
        },
        {
            "name": "libcyaml",
            "description": "LibCYAML is a C library for reading and writing structured YAML\ndocuments. It is written in ISO C11 and licensed under the ISC licence."
        },
        {
            "name": "dtc",
            "description": "Device Tree Compiler (dtc) toolchain for working with device tree source\nand binary files and also libfdt, a utility library for reading and\nmanipulating the binary format."
        },
        {
            "name": "petsc",
            "description": "PETSc is a suite of data structures and routines for the scalable\n(parallel) solution of scientific applications modeled by partial\ndifferential equations."
        },
        {
            "name": "barvinok",
            "description": "barvinok is a library for counting the number of integer points in\nparametric and non-parametric polytopes."
        },
        {
            "name": "slurm",
            "description": "Slurm is an open source, fault-tolerant, and highly scalable cluster\nmanagement and job scheduling system for large and small Linux clusters.\nSlurm requires no kernel modifications for its operation and is\nrelatively self-contained. As a cluster workload manager, Slurm has\nthree key functions. First, it allocates exclusive and/or non-exclusive\naccess to resources (compute nodes) to users for some duration of time\nso they can perform work. Second, it provides a framework for starting,\nexecuting, and monitoring work (normally a parallel job) on the set of\nallocated nodes. Finally, it arbitrates contention for resources by\nmanaging a queue of pending work."
        }
    ]
}